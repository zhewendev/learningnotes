# 构造器

1. **不能被<font color =red>static、final、synchronized、abstract、native</font>修饰，不能有return语句返回值**
2. **父类的构造器不可被子类继承**
3. <font color=red>**类中属性赋值的先后顺序：**</font>1.属性的默认初始化2数据的显示赋值3.通过构造器给属性初始化4.创建对象后，通过对象。方法的形式给属性赋值
4. 初始化引用的一种方式，**惰性初始化**。

# 方法

1. 不能在方法中再定义方法。
2. 方法重载是在一个类中，使用方法名相同但是参数列表不同（参数个数，参数类型）<font color=red>**只看参数列表**</font>，与返回类型也无关
3. 重写方法必须和被重写方法具有**相同的方法名称、参数列表和返回值类型**，同时为static或非static，子类异常不大于父类异常。访问权限不能更严格。
4. 只有非private方法才可以被覆盖；不然则视为子类中的新方法

# this

1. <font color=red>**this**关键字只能在方法内部使用</font>
2. 在方法中调用同类中另一个方法，直接调用就可以，不用添加this，编译器默认添加。
3. 明确指出对当前对象的引用时，需要使用this。例如：`return this`
4. 使用this调用本类中其他的构造器，保证至少有一个构造器是不用this的。且this语句必须是放在构造器首行

# static

1. static 方法就是没有this的方法，不能调用非静态方法。
2. 不能用于局部变量
3. 初始化时先静态对象，再非静态对象。且静态对象只初始化一次
4. 不创建对象或访问静态数据，静态初始化不会进行
5. **static静态块只执行一次，访问静态方法或创建对象等，首次要初始化这个静态块**
6. 重载的方法需要同时是static或非static的

# finalize()

1. **fianlize()需求限制情况**：通过某种创建对象方式以外的方式为对象分配了存储空间
2. finalize()是的对象应该处于某种状态，使它占用的内存可以被安全地释放。如果对象打开了一个文件，回收前要关闭文件。finalize()可以用来发现这种情况
3. 调用垃圾回收或finalize()：`System.gc`,`System.runFinalization()`
4. 垃圾回收的顺序与对象初始化顺序相反

# 类的成员变量

1. 成员变量存在堆空间，有初始值；局部变量在栈空间，要显式赋值
2. **变量定义的先后顺序决定了初始化的顺序。变量定义散布于方法定义之间，它们仍旧会在任何方法（构造器）被调用之前得到初始化**
3. 

# 数组

1. 可变参数列表和自动包装机制可以和谐共处。
2. 可变参数增加了重载的复杂性，可以加入一个非可变参数

# enum

1. 注意枚举类中**values()**方法和**ordinal()**方法。

# 继承

1. 为了继承，一般基类的所有数据成员都指定为private，所有方法指定为public
2. 慎用继承，判断是否需要从新类向基类进行向上转型

# 代理

1. 代理是组合和继承之外的第三种关系，二者的中庸

# 清理对象

1. 在类生命周期内执行一些必须清理动作，需显式编写特殊方法来执行，且确保客户端程序员知晓他们必须要调用这个方法。首要动作将这一清理动作置于finally子句中，预防异常的出现。
2. **<font color =red>执行类的特定清理动作，顺序同生成顺序相反</font>**（基类元素仍旧存活）

# 组合

1. 组合用于想在新类中使用现有类的功能而非它的接口这种情形。一般在**新类中嵌入一个现有类的private对象**。

# final

1. **final数据必须是基本数据类型且在定义时必须对其赋值**，或者在构造器处为其赋值。
2. 既是static又是final的域，将用大写表示，下划线分隔
3. final参数意味不可在方法中更改引用所指对象。

# 绑定

1. **后期绑定**就是在运行时根据对象的类型进行绑定（也称动态绑定或运行时绑定）。
2. Java中**除了static**方法和**final**方法（private属于final方法）之外，其他方法都是后期绑定。

# 多态

1. 只有普通的方法调用是多态的，域和静态方法是不存在
2. 构造器不具有多态性
3. **在构造器中调用一个动态绑定方法，就要用到那个方法的被覆盖的定义。这个效果难以预料，这个方法操纵的成员可能还没有进行初始化**

# 向下转型

1. java中提供了instanceof 操作符确保向下转型的正确性
2. x instanceof A：检验x是否是类A的对象。如果x属于类A的子类B，也为true，转换后调用子类B重写的方法。

# 抽象类

1. 不能用abstract修饰属性，私有方法，构造器，静态方法，final的方法，即private，static，final。
2. 如果基类是抽象类，使用多态时无需再向下转型

# 接口

1. 接口支持多重继承，确定方法名，参数列表和返回类型
2. 接口是**抽象方法**和**常量值**的定义集合，**无构造器**。
3. 接口中定义的域不能是“空final”。
4. 接口中的域在第一次加载被初始化，发生在任何域首次被访问时。

# 内部类

1. **它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。**
2. 需要生成对外部类对象的引用，可以使用：**<font color=red>外部类名字.this</font>**
3. 告知某些其他对象，创建其某个内部类的对象，需要使用：<font color=red>**.new**</font>
4. 拥有外部类对象之前不可能创建内部类对象的（除了静态内部类）
5. **内部类可以定义在方法里，作用域内，称为<font color=red>局部内部类</font>**，该内部类仅在方法内或作用域内可用。
6. 匿名内部类：将返回值的生成与表示这个返回值的类定义结合在一起。**这种语法是指**：创建一个继承自基类的匿名类的对象，通过new表达式返回的引用被自动向上转型为基类的引用
7. **定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器回要求其参数引用的是final**
8. **不需要内部类与外围类对象之间有联系，那么可以将内部类声明为static，这通常称之为<font color=red>嵌套类</font>**。
9. **普通内部类不能有static数据和static字段**，也不能包含嵌套类，但是嵌套类可以包含这些东西。
10. 嵌套类可以作为接口的一部分，**甚至可以在内部类实现外围接口**。
11. 如果是抽象类或者具体地类，只有使用内部类才能够实现多重继承。
12. 如果一个类只继承了 内部类，不是外围类，但是当要生成一个构造器时，必须在构造器内使用：`enclosingClassReference.super()`，这样才提供了必要的引用
13. **如果一个类A继承了类B，类A的内部类继承了类B的内部类，则类A内部类的构造器可以不用像上述小结中内部类继承那样提供必要的引用。如果类A继承了类B但是内部类没有继承类B中内部类，那么两个内部类是两个独立的实体**。
14. 用局部内部类而非匿名内部类的两个理由
15. 

# 注解

1. @SuppressWarnings("...")

   表示只有有关不受检查的异常的警告信息应该被抑制。



# 容器

1. 如果容器对象是自动包装类，注意equals()方法。且注意例如remove(2)与remove(Integer.valueOf(2))之间的不同。
2. java的Iterator只能单向移动，能够将遍历序列操作与序列底层结构分离。
3. **ListIterator是一种更强大的Iterator的子类型，它只能用于各种List类的访问**。可以双向移动，还可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素。可以调用listIterator()方法产生一个指向List开始处的ListIterator，并且还可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。
4. **LinkedList能够直接实现栈的所有功能的方法，因此可以将LinkedList当做栈使用。**
5. Set不保存重复的元素，测试归属性性一般选择HashSet实现，专门对快速查找进行了优化。
6. Set具有和Collection一样的接口，二者行为不同。

