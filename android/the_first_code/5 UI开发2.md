# 1 ViewPager简单使用

参考文献：

1. [参考文献一](http://www.runoob.com/w3cnote/android-tutorial-viewpager.html)
2. [参考文献二](https://juejin.im/post/5a4c2f496fb9a044fd122631)
3. [参考文献三](https://www.jianshu.com/p/e5abbda4a71c)
4. [参考文献四](https://www.jianshu.com/p/6b1008fcc082)

**ViewPager**主要包括以下内容：

- ViewPager 基本使用（简介、适配器）
- ViewPager + TabLayout + Fragment 的使用
- ViewPager 轮播图的使用（指示器、标题、自动轮播、首尾循环）
- ViewPager 的切换效果（PageTransformer）
- ViewPager 切换效果进阶

## ViewPager基础介绍

ViewPager就是一个简单的页面切换组件，我们可以往里面填充多个View，然后我们可以左 右滑动，从而切换不同的View。

> 这里简单归结如下：
>
> - ViewPager 是 v4 包中的一个类。
> - ViewPager 类直接继承了 ViewGroup 类，它是一个容器类，可以在其中添加其他的 view 。
> - 类似于 ListView，也有自己的适配器，用来填充数据页面



ViewPager常用的可以动态设置方法有：

- `setAdapter(PagerAdapter adapter)` 设置适配器

- `setOffscreenPageLimit(int limit)` 设置缓存的页面个数,默认是 1

- `setCurrentItem(int item)` 跳转到特定的页面

- `setOnPageChangeListener(..)` 设置页面滑动时的监听器（现在API中建议使用 `addOnPageChangeListener(..)`）

- `setPageTransformer(..PageTransformer)` 设置页面切换时的动画效果

- `setPageMargin(int marginPixels)` 设置不同页面之间的间隔

- `setPageMarginDrawable(..)` 设置不同页面间隔之间的装饰图也就是 divide ，要想显示设置的图片，需要同时设置 `setPageMargin()`

前面学的ListView，GridView一样，我们也需要一个Adapter (适配器)将我们的View和ViewPager进行绑定，而ViewPager则有一个特定的Adapter—— **PagerAdapter**！

Google官方是建议我们使用Fragment来填充ViewPager的，这样 可以更加方便的生成每个Page，以及管理每个Page的生命周期！给我们提供了两个Fragment 专用的Adapter：**FragmentPageAdapter**和**FragmentStatePagerAdapter** 我们简要的来分析下这两个Adapter的区别：

- **FragmentPageAdapter**：和PagerAdapter一样，只会缓存当前的Fragment以及左边一个，右边 一个，即总共会缓存3个Fragment而已，假如有1，2，3，4四个页面：
  处于1页面：缓存1，2
  处于2页面：缓存1，2，3
  处于3页面：销毁1页面，缓存2，3，4
  处于4页面：销毁2页面，缓存3，4
  更多页面的情况，依次类推~
- **FragmentStatePagerAdapter**：当Fragment对用户不 见得时，整个Fragment会被销毁， 只会保存Fragment的状态！而在页面需要重新显示的时候，会生成新的页面！

综上，**FragmentPageAdapter适合固定的页面较少的场合；而FragmentStatePagerAdapter则适合 于页面较多或者页面内容非常复杂**(需占用大量内存)的情况！



## PagerAdapter的使用

PagerAdapter 是抽象的类，所以使用时只能使用它的子类，即**FragmentPageAdapter**和**FragmentStatePagerAdapter** 。

**实现子类必须实现一下四个方法**（一般重写`getCount()`与`isViewFromObject()`即可）：

- `getCount();` 是获取当前窗体界面数，也就是数据的个数。即Viewpager中有多少个view
- `destroyItem(ViewGroup container, int position, Object object);` 如果页面不是当前显示的页面也不是要缓存的页面，会调用这个方法，将页面销毁。确保在`finishUpdate(viewGroup)`返回时视图能够被移除。
- `instantiateItem(View container, int position);` 要显示的页面或需要缓存的页面，会调用这个方法进行布局的初始化。
- `isViewFromObject(View view, Object object);` 这个方法用于判断是否由对象生成界面，官方建议直接返回 `return view == object;`。

**ViewPager的常用方法有**：

- **setAdapter(PagerAdapter adapter)**
   建立与适配器的联系
   adapter:与ViewPager配合使用的适配器

-  **ViewPager.getCurrentItem()**

   返回当前页的索引，也就是返回当前显示的页码；

   adapter:与ViewPager配合使用的适配器

-  **ViewPager.setCurrentItem(int position)**

   设置当前页，position:被设置的当前页的索引；

### PagerAdapter最简单用法

**<font color = red>示例</font>**：

- 编写每个View的布局，（view_one.xml）

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <LinearLayout
      xmlns:android="http://schemas.android.com/apk/res/android"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:background="#FFBA55"
      android:gravity="center"
      android:orientation="vertical">
  
      <TextView
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="第一个Page"
          android:textColor="#000000"
          android:textSize="18sp"
          android:textStyle="bold" />
  
  </LinearLayout>
  ```

- 编写activity_main.xml布局

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
      android:orientation="vertical"
      android:layout_width="match_parent"
      android:layout_height="match_parent">
  
      <android.support.v4.view.ViewPager
          android:id="@+id/vpager_one"
          android:layout_width="match_parent"
          android:layout_height="match_parent"/>
  </LinearLayout>
  ```

- 编写自定义的PagerAdapter

  ```java
  public class MyPagerAdapter extends PagerAdapter {
  
      private ArrayList<View> viewLists;
  
      public MyPagerAdapter() {
  
      }
  
      public MyPagerAdapter(ArrayList<View> viewLists) {
          super();
          this.viewLists = viewLists;
      }
  
      @Override
      public int getCount() {
          return viewLists.size();
      }
  
      @Override
      public boolean isViewFromObject(@NonNull View view, @NonNull Object o) {
          return view == o;
      }
  
      @NonNull
      @Override
      public Object instantiateItem(@NonNull ViewGroup container, int position) {
          container.addView(viewLists.get(position));
          return viewLists.get(position);
      }
  
      @Override
      public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
          container.removeView(viewLists.get(position));
      }
  }
  ```

- 编写MainActivity.java代码

  ```java
  public class MainActivity extends AppCompatActivity {
  
      private ViewPager vpager_one;
      private ArrayList<View> aList;
      private MyPagerAdapter mAdapter;
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_main);
          vpager_one = (ViewPager) findViewById(R.id.vpager_one);
  
          aList = new ArrayList<View>();
          LayoutInflater li = getLayoutInflater();
          aList.add(li.inflate(R.layout.view_one,null,false));
          aList.add(li.inflate(R.layout.view_two,null,false));
          aList.add(li.inflate(R.layout.view_three,null,false));
          aList.add(li.inflate(R.layout.view_one,null,false));
          mAdapter = new MyPagerAdapter(aList);
          vpager_one.setAdapter(mAdapter);
      }
  }
  ```

### 标题栏——PagerTitleStrip与PagerTabStrip

标题栏，即随着ViewPager滑动而滑动的标题。**前一个是普通文字，后一个是带有下划线以及可以点击文字切换页面**。

二者的代码区别：**仅仅是布局不同**

- PagerTitleStrip所在Activity布局：activity_two.xml

  ```xml
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:orientation="vertical">
  
      <TextView
          android:layout_width="match_parent"
          android:layout_height="48dp"
          android:background="#CCFF99"
          android:gravity="center"
          android:text="PagerTitleStrip效果演示"
          android:textColor="#000000"
          android:textSize="18sp" />
  
      <android.support.v4.view.ViewPager
          android:id="@+id/vpager_two"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:layout_gravity="center">
  
          <android.support.v4.view.PagerTitleStrip
              android:id="@+id/pagertitle"
              android:layout_width="wrap_content"
              android:layout_height="40dp"
              android:layout_gravity="top"
              android:textColor="#000000" />
      </android.support.v4.view.ViewPager>
  
  </LinearLayout>
  ```

- PagerTabStrip所在布局：activity_three.xml:

  ```xml
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:orientation="vertical">
  
      <TextView
          android:layout_width="match_parent"
          android:layout_height="35dp"
          android:background="#C0C080"
          android:gravity="center"
          android:text="PagerTabStrip效果演示"
          android:textSize="18sp" />
  
      <android.support.v4.view.ViewPager
          android:id="@+id/vpager_three"
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:layout_gravity="center">
  
          <android.support.v4.view.PagerTabStrip
              android:id="@+id/pagertitle"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="top" />
      </android.support.v4.view.ViewPager>
  </LinearLayout>
  ```

- 编写自定义的PagerAdapter，需要额外重写一个方法：getPageTitle()，用来设置标题

  ```java
  public class MyPagerAdapter extends PagerAdapter {
  
      private ArrayList<View> viewLists;
      private ArrayList<String> titleLists;
  
      public MyPagerAdapter() {
  
      }
  
      public MyPagerAdapter(ArrayList<View> viewLists, ArrayList<String> titleLists) {
          super();
          this.viewLists = viewLists;
          this.titleLists = titleLists;
      }
  
      @Override
      public int getCount() {
          return viewLists.size();
      }
  
      @Override
      public boolean isViewFromObject(@NonNull View view, @NonNull Object o) {
          return view == o;
      }
  
      @NonNull
      @Override
      public Object instantiateItem(@NonNull ViewGroup container, int position) {
          container.addView(viewLists.get(position));
          return viewLists.get(position);
      }
  
      @Override
      public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
          container.removeView(viewLists.get(position));
      }
  
      @Nullable
      @Override
      public CharSequence getPageTitle(int position) {
          return titleLists.get(position);
      }
  }
  ```

- 最后编写MainActivity.java代码

  ```java
  public class MainActivity extends AppCompatActivity {
  
      private ViewPager vpager_two;
      private ArrayList<View> aList;
      private ArrayList<String> sList;
      private MyPagerAdapter mAdapter;
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_three);
          vpager_two = (ViewPager) findViewById(R.id.vpager_three);
  
          aList = new ArrayList<View>();
          LayoutInflater li = getLayoutInflater();
          aList.add(li.inflate(R.layout.view_one,null,false));
          aList.add(li.inflate(R.layout.view_two,null,false));
          aList.add(li.inflate(R.layout.view_three,null,false));
          sList = new ArrayList<String >();
          sList.add("橘黄");
          sList.add("淡黄");
          sList.add("浅棕");
          mAdapter = new MyPagerAdapter(aList, sList);
          vpager_two.setAdapter(mAdapter);
      }
  }
  ```









# 2 Handler

**参考文献**：

1. [API](https://developer.android.com/reference/android/os/Handler)
2. [参考文献一](http://www.runoob.com/w3cnote/android-tutorial-handler-message.html)
3. [参考文献二](http://www.cnblogs.com/plokmju/p/android_handler.html)
4. [参考文献三](https://segmentfault.com/a/1190000005926314#articleHeader4)（代码待验证）

------

Handler是Activity中UI组件中用来信息传递的。Android为了线程安全，并**不允许我们在UI线程外操作UI**；很多时候我们做界面刷新都需要通过Handler来通知UI组件更新！除了用Handler完成界面更新外，还可以使用`runOnUiThread()`来更新，甚至更高级的事务总线

![](http://www.runoob.com/wp-content/uploads/2015/07/70402782.jpg)

## Handler作用与相关方法

![](http://www.runoob.com/wp-content/uploads/2015/07/90456225.jpg)

　[Handler](http://developer.android.com/reference/android/os/Handler.html)，它直接继承自Object，一个Handler允许发送和处理Message或者Runnable对象，并且会关联到主线程的MessageQueue中。**每个Handler具有一个单独的线程**，并且关联到一个消息队列的线程，就是说一个Handler有一个固有的消息队列。当实例化一个Handler的时候，它就承载在一个线程和消息队列的线程，这个Handler可以把Message或Runnable压入到消息队列，并且从消息队列中取出Message或Runnable，进而操作它们

**Handler主要有两个作用**：

- 在工作线程中发送消息。
- 在UI线程中获取、处理消息。

　　上面介绍到Handler可以把一个Message对象或者Runnable对象压入到消息队列中，进而在UI线程中获取Message或者执行Runnable对象，所以Handler把压入消息队列有两大体系，Post和sendMessage：

- **Post**：Post允许把一个**Runnable对象**入队到消息队列中。它的方法有：`post(Runnable)`、`postAtTime(Runnable,long)`、`postDelayed(Runnable,long)`。
- **sendMessage**：sendMessage允许把一个包含消息数据的**Message对象**压入到消息队列中。它的方法有：`sendEmptyMessage(int)`、`sendMessage(Message)`、`sendMessageAtTime(Message,long)`、`sendMessageDelayed(Message,long)`。

　　从上面的各种方法可以看出，不管是post还是sendMessage都具有多种方法，它们可以设定Runnable对象和Message对象被入队到消息队列中，是立即执行还是延迟执行。

**<font color = red>Handler的执行流程图</font>**：

![](http://www.runoob.com/wp-content/uploads/2015/07/25345060.jpg)

- **UI线程**：就是我们的**主线程**,系统在创建UI线程的时候会初始化一个Looper对象,同时也会创建一个与其关联的**MessageQueue**;
- **Handler**:作用就是发送与处理信息,如果希望Handler正常工作,在当前线程中要有一个Looper对象
- **Message**:Handler接收与处理的消息对象
- **MessageQueue**:消息队列,先进先出管理Message,在初始化Looper对象时会创建一个与之关联的MessageQueue;
- **Looper**:每个线程只能够有一个Looper,管理MessageQueue,不断地从中取出Message分发给对应的Handler处理！

![](https://upload-images.jianshu.io/upload_images/2496578-7139a26b99a3a1de?imageMogr2/auto-orient/strip%7CimageView2/2/w/724/format/webp)

> 想修改Activity中的UI组件时,我们可以新建一个Handler对象,通过这个对象向主线程发送信息;而我们发送的信息会先到主线程的MessageQueue进行等待,由Looper按先入先出顺序取出,再根据message对象的what属性分发给对应的Handler进行处理！

### Message

Handler如果使用**sendMessage**的方式把消息入队到消息队列中，需要传递一个Message对象，而在Handler中，需要**重写`handleMessage()`方法**，用于获取工作线程传递过来的消息，此方法运行在UI线程上

Message是一个final类，**不可被继承**。Message封装了线程中传递的消息，如果对于一般的数据，Message提供了`getData()`和`setData()`方法来获取与设置数据，其操作的数据是一个Bundle对象。对于复杂的数据类型，在Bundle中提供了两种方法：

- `putParcelable(String key,Parcelable value)`：需要传递的对象类实现Parcelable接口。
- `pubSerializable(String key,Serializable value)`：需要传递的对象类实现Serializable接口。

**Message自带的有如下属性**：

- int arg1：参数一，用于传递不复杂的数据，复杂数据使用setData()传递
- int arg2：参数二，用于传递不复杂的数据，复杂数据使用setData()传递
- Object obj：传递一个任意的对象
- int what：定义的消息码，用于设定消息的标志。

对于Message对象，建议通过使用`Message.obtain()`这个静态的方法或者`Handler.obtainMessage()`获取。Message.obtain()会从消息池中获取一个Message对象，如果消息池中是空的，才会使用构造方法实例一个新Message，有利于资源的利用。消息池中资源有上限，上限为10个。Handler.obtainMessage()具有多个重载方法。





**Handler相关方法**：

- void **handleMessage**(Message msg):处理消息的方法,通常是用于被重写!
- **sendEmptyMessage**(int what):发送空消息
- **sendEmptyMessageDelayed**(int what,long delayMillis):指定延时多少毫秒后发送空信息
- **sendMessage**(Message msg):立即发送信息
- **sendMessageDelayed**(Message msg):指定延时多少毫秒后发送信息
- final boolean **hasMessage**(int what):检查消息队列中是否包含what属性为指定值的消息 如果是参数为(int what,Object object):除了判断what属性,还需要判断Object属性是否为指定对象的消息

### Handler写在主线程中

> 在主线程中，是因为系统已经初始化了一个Looper对象，直接创建Handler对象，就可以进行信息发送与处理

**示例**（简单定时切换图片）

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/RelativeLayout1"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    tools:context="com.vivo.a11085273.handlertest.MainActivity" >

    <ImageView
        android:id="@+id/imgchange"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentTop="true" />

</RelativeLayout>
```

```java
public class MainActivity extends AppCompatActivity {

    //定义切换的图片的数组id
    int imgids[] = new int[]{
            R.drawable.apple_pic, R.drawable.banana_pic,R.drawable.cherry_pic,
            R.drawable.grape_pic,R.drawable.pear_pic,R.drawable.pineapple_pic,
            R.drawable.strawberry_pic,R.drawable.watermelon_pic
    };
    int imgstart = 0;
    ImageView imgchange;

    final Handler myHandler = new Handler() {
        @Override
        //重写handleMessage方法,根据msg中what的值判断是否执行后续操作
        public void handleMessage(Message msg) {
            if(msg.what == 0x123) {
                imgchange.setImageResource(imgids[imgstart++ % 8]);
            }
        }
    };


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
       imgchange = (ImageView) findViewById(R.id.imgchange);

        //使用定时器,每隔200毫秒让handler发送一个空信息
        new Timer().schedule(new TimerTask() {
            @Override
            public void run() {
                myHandler.sendEmptyMessage(0x123);
            }
        }, 0,200);
    }

}
```

### Handler写在子线程中

Handler写在子线程中，就需要自己创建一个Looper对象。创建流程为：

> **1 )**直接调用Looper.prepare()方法即可为当前线程创建Looper对象,而它的构造器会创建配套的MessageQueue; **2 )**创建Handler对象,重写handleMessage( )方法就可以处理来自于其他线程的信息了! **3 )**调用Looper.loop()方法启动Looper

**示例**（输入一个数，计算后通过Toast输出这个范围内的所有质数）

- 编写布局文件`activity_main.xml`

  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <LinearLayout
      xmlns:android="http://schemas.android.com/apk/res/android"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:orientation="vertical">
      <EditText
          android:id="@+id/etNum"
          android:inputType="number"
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:hint="请输入上限"/>
      <Button
          android:layout_width="match_parent"
          android:layout_height="wrap_content"
          android:onClick="cal"
          android:text="计算"/>
  </LinearLayout>
  ```

- 编写`MainActivity.java`

  ```java
  public class MainActivity extends AppCompatActivity {
          static final String UPPER_NUM = "upper";
          EditText etNum;
          CalThread calThread;
          // 定义一个线程类
          class CalThread extends Thread
          {
              public Handler mHandler;
  
              public void run()
              {
                  Looper.prepare();
                  mHandler = new Handler()
                  {
                      // 定义处理消息的方法
                      @Override
                      public void handleMessage(Message msg)
                      {
                          if(msg.what == 0x123)
                          {
                              int upper = msg.getData().getInt(UPPER_NUM);
                              List<Integer> nums = new ArrayList<Integer>();
                              // 计算从2开始、到upper的所有质数
                              outer:
                              for (int i = 2 ; i <= upper ; i++)
                              {
                                  // 用i处于从2开始、到i的平方根的所有数
                                  for (int j = 2 ; j <= Math.sqrt(i) ; j++)
                                  {
                                      // 如果可以整除，表明这个数不是质数
                                      if(i != 2 && i % j == 0)
                                      {
                                          continue outer;
                                      }
                                  }
                                  nums.add(i);
                              }
                              // 使用Toast显示统计出来的所有质数
                              Toast.makeText(MainActivity.this , nums.toString()
                                      , Toast.LENGTH_LONG).show();
                          }
                      }
                  };
                  Looper.loop();
              }
          }
          @Override
          public void onCreate(Bundle savedInstanceState)
          {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.activity_main);
              etNum = (EditText)findViewById(R.id.etNum);
              calThread = new CalThread();
              // 启动新线程
              calThread.start();
          }
          // 为按钮的点击事件提供事件处理函数
          public void cal(View source)
          {
              // 创建消息
              Message msg = Message.obtain();
              msg.what = 0x123;
              Bundle bundle = new Bundle();
              bundle.putInt(UPPER_NUM ,
                      Integer.parseInt(etNum.getText().toString()));
              msg.setData(bundle);
              // 向新线程中的Handler发送消息
              calThread.mHandler.sendMessage(msg);
          }
      }
  ```



# 3 HandlerThread

参考文献：

- [API](https://developer.android.com/reference/android/os/HandlerThread)
- [参考文献一](https://blog.csdn.net/javazejian/article/details/52426353)
- [参考文献二](https://blog.csdn.net/lmj623565791/article/details/47079737)

------

**HandlerThread的特点**：

- HandlerThread本质上是一个线程类，它继承了Thread；
- HandlerThread有自己的内部Looper对象，可以进行looper循环
- 通过获取HandlerThread的looper对象传递给Handler对象，可以在`handleMessage`方法中执行异步任务
- 创建HandlerThread后必须先调用`HandlerThread.start()`方法，Thread会先调用`run`方法，创建Looper对象

## 常规用法

- 创建实例对象

  ```java
  HandlerThread handlerThread = new HandlerThread("downloadImage");
  ```

- 启动HandlerThread线程

  ```java
  handlerThread.start();
  ```

- 构建循环消息处理机制

  ```java
  /**
       * 该callback运行于子线程
       */
      class ChildCallback implements Handler.Callback {
          @Override
          public boolean handleMessage(Message msg) {
              //在子线程中进行相应的网络请求
  
              //通知主线程去更新UI
              mUIHandler.sendMessage(msg1);
              return false;
          }
      }
  ```

- 构建异步handler

  ```java
  //子线程Handler
  Handler childHandler = new Handler(handlerThread.getLooper(),new ChildCallback());
  ```




示例：

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ImageView
        android:id="@+id/image"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</LinearLayout>
```

```java
public class MainActivity extends AppCompatActivity {

    /**
     * 图片地址集合
     */
    private String url[]={
            "https://www.qqkw.com/d/file/p/2018/06-15/5f57a69b79ef4f41ecaa94fed9a63478.jpg",
            "https://www.qqkw.com/d/file/p/2018/06-15/02ec6b0d355382658e5616d80294a3c0.jpg",
            "https://www.qqkw.com/d/file/p/2018/06-15/ba7849f05cb092e5902dfabad9fae4c5.jpg",
            "https://www.qqkw.com/d/file/p/2018/06-15/02ec6b0d355382658e5616d80294a3c0.jpg",
            "https://www.qqkw.com/d/file/p/2018/06-15/5f57a69b79ef4f41ecaa94fed9a63478.jpg"
    };
    private ImageView imageView;
    @SuppressLint("HandlerLeak")
    private Handler mUIHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
//            LogUtils.e("次数："+ msg.what);
            ImageModel model = (ImageModel) msg.obj;
            imageView.setImageBitmap(model.bitmap);
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        imageView = (ImageView) findViewById(R.id.image);
        //创建异步HandlerThread
        HandlerThread handlerThread = new HandlerThread("downloadImage");
        //必须先开启线程
        handlerThread.start();
        //子线程Handler
        Handler childHandler = new Handler(handlerThread.getLooper(), new ChildCallback());
        for (int i = 0; i < 5; i++) {
            //每秒1秒去更新图片
            childHandler.sendEmptyMessageDelayed(i, 1000 * i);
        }
    }
    //Callback运行于子线程
    class ChildCallback implements Handler.Callback {
        @Override
        public boolean handleMessage(Message msg) {
            //子线程中进行网络请求
            Bitmap bitmap = downloadUrlBitmap(url[msg.what]);
            ImageModel imageModel = new ImageModel();
            imageModel.bitmap = bitmap;
            imageModel.url = url[msg.what];
            Message msg1 = Message.obtain();
            msg1.what = msg.what;
            msg1.obj = imageModel;
            //通知主线程去更新UI
            mUIHandler.sendMessage(msg1);
            return false;
        }
    }

    private Bitmap downloadUrlBitmap(String urlString) {
        HttpURLConnection urlConnection = null;
        BufferedInputStream in = null;
        Bitmap bitmap=null;
        try {
            final URL url = new URL(urlString);
            urlConnection = (HttpURLConnection) url.openConnection();
            in = new BufferedInputStream(urlConnection.getInputStream(), 8 * 512);
            bitmap=BitmapFactory.decodeStream(in);
        } catch (final IOException e) {
            e.printStackTrace();
        } finally {
            if (urlConnection != null) {
                urlConnection.disconnect();
            }
            try {
                if (in != null) {
                    in.close();
                }
            } catch (final IOException e) {
                e.printStackTrace();
            }
        }
        return bitmap;
    }
}
class ImageModel {
    String url;
    public Bitmap bitmap;
}
```

```xml
<uses-permission android:name="android.permission.INTERNET"/>
```

示例2：

```java
public class MainActivity extends AppCompatActivity {

    private TextView timeTextView;
    private Button timeButton;

    @SuppressLint("HandlerLeak")
    final  Handler mUiHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            if (msg.what == 0x123) {
                timeTextView.setText(msg.getData().getString("currentTime"));
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        timeButton = (Button) findViewById(R.id.time_button);
        timeTextView = (TextView) findViewById(R.id.time_text_view);
        HandlerThread handlerThread = new HandlerThread("getCurrentTime");
        handlerThread.start();
        final Handler childHandler = new Handler(handlerThread.getLooper(), new ChildCallback());
        timeButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                childHandler.sendEmptyMessage(0x123);
            }
        });

    }

    class ChildCallback implements Handler.Callback {
        @Override
        public boolean handleMessage(Message msg) {
            if (msg.what == 0x123) {
                Message returnMsg = Message.obtain();
                returnMsg.what = 0x123;
                Bundle bd = new Bundle();
                SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
                Date date = new Date(System.currentTimeMillis());
                String time = simpleDateFormat.format(date);
                bd.putString("currentTime", time);
                returnMsg.setData(bd);
                mUiHandler.sendMessageDelayed(returnMsg, 5000);
            }
            return false;
        }
    }
}
```



# 4 Toast



**参考文献**：

- 参考文献一：[Android指南](https://developer.android.com/guide/topics/ui/notifiers/toasts#java)
- 参考文献二：[菜鸟教程](http://www.runoob.com/w3cnote/android-tutorial-toast.html)
- 参考文献三：[ForrestWoo博客](https://www.cnblogs.com/salam/archive/2010/11/10/1873654.html)
- 参考文献四：第一行代码

------

Toast是Android中系统提供的一种提醒方式**，讲一些短小的信息通知给用户，一段时间后自动消失。

## 默认效果

**Toast.makeText(MainActivity.this, "提示的内容", Toast.LENGTH_LONG).show();** 第一个是上下文对象！对二个是显示的内容！第三个是显示的时间，只有LONG和SHORT两种 会生效

```java
Context context = getApplicationContext();
CharSequence text = "Hello toast!";
int duration = Toast.LENGTH_SHORT;

Toast toast = Toast.makeText(context, text, duration);
toast.show();
```

或：

```java
Toast.makeText(getApplicationContext(), "默认Toast样式",
     Toast.LENGTH_SHORT).show();
```

## 自定义显示位置

标准Toast通知出现在屏幕底部附近，水平居中，可以使用`setGravity(int, int, int)`方法更改该位置。三个参数为：**Gravity**常数、x位置水平偏移、y位置水平偏移

```java
toast.setGravity(Gravity.CENTER_VERTICAL|Gravity.CENTER_HORIZONTAL , 0, 0);  //设置显示位置
toast.show();
```

## 带图片的Toast

```java
Toast toast = Toast.makeText(getApplicationContext(),
        "带图片的Toast", Toast.LENGTH_LONG);
LinearLayout toastView = (LinearLayout) toast.getView();//获取布局
toastView.setBackgroundColor(Color.BLUE);//设置布局背景颜色
ImageView image = new ImageView(getApplicationContext());
image.setImageResource(R.mipmap.ic_launcher);
toastView.addView(image, 0);//在第0处添加图片
TextView v = (TextView) toast.getView().findViewById(android.R.id.message);//获取字体
v.setTextColor(Color.YELLOW);     //设置字体颜色
toast.show();
```

## 自定义效果

- 设置布局文件：**custom_toast.xml**

  ```xml
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:id="@+id/custom_toast_container"
                android:orientation="horizontal"
                android:layout_width="fill_parent"
                android:layout_height="fill_parent"
                android:padding="8dp"
                android:background="#DAAA"
                >
      <ImageView android:src="@drawable/droid"
                 android:layout_width="wrap_content"
                 android:layout_height="wrap_content"
                 android:layout_marginRight="8dp"
                 />
      <TextView android:id="@+id/text"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textColor="#FFF"
                />
  </LinearLayout>
  ```

- 关键代码

  ```java
  LayoutInflater inflater = getLayoutInflater();
  View layout = inflater.inflate(R.layout.custom_toast,
                  (ViewGroup) findViewById(R.id.custom_toast_container));
  
  TextView text = (TextView) layout.findViewById(R.id.text);
  text.setText("This is a custom toast");
  
  Toast toast = new Toast(getApplicationContext());
  toast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
  toast.setDuration(Toast.LENGTH_LONG);
  toast.setView(layout);
  toast.show();
  ```



# 5 Menu

**参考文献**：

- 参考文献一：[Android指南](https://developer.android.com/guide/topics/ui/menus)
- 参考文献二：[菜鸟教程](http://www.runoob.com/w3cnote/android-tutorial-menu.html)
- 参考文献三：[CodingEnding博客](https://blog.csdn.net/CodingEnding/article/details/78609902)
- 参考文献四：第一行代码

------

## Menu总览

对于所有的菜单类型，Android提供了标准的XML格式定义菜单项。在XML[菜单资源](https://developer.android.com/guide/topics/resources/menu-resource.html?hl=zh-cn)中定义菜单及其所有项，而非在Activity中构建菜单。可以在Activity或片段中扩充菜单资源。

定义菜单，现在项目res/menu/目录中创建一个xml文件，新建menu文件夹和main菜单文件，添加代码：

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item
        android:id="@+id/add_item"
        android:title="Add"/>
    <item
        android:id="@+id/remove_item"
        android:title="Remove"/>
</menu>
```

- `<menu>`：

  定义 `Menu`，即菜单项的容器。`<menu>` 元素必须是该文件的根节点，并且能够包含一个或多个`<item>` 和 `<group>` 元素。

- `<item>`：

  创建 `MenuItem`，此元素表示菜单中的一项，**可能包含嵌套**的 `<menu>` 元素，以便创建子菜单。

- `<group>`：

  是`<item>` 元素的不可见容器（可选）。它支持您对菜单项进行分类，使其共享活动状态和可见性等属性。


前述的几种属性中，`<item>`是主要的关注对象，常见属性为：

- `android:id`：菜单项(MenuItem)的唯一标识

- `android:icon`：菜单项的图标（可选）
- `android:title`：菜单项的标题（必选）
- `android:showAsAction`:指定菜单项的显示方式，常用的有`ifRoom`、`never`、`always`、`withText`。多个属性值之间用`|`隔开

菜单栏中菜单项会分为两个部分，一部分可以直接在菜单栏中看见，称之为**常驻菜单**；另一部分会被集中收纳到**溢出菜单**中（菜单栏右侧的小点状图标）。一般情况下，常驻菜单项以图标形式显示（需要定义`icon`属性），而溢出菜单项则以文字形式显示（通过`title`属性定义）。

**`showAsAction`差异如下**：

- `always`：菜单项永远不会被收纳到溢出菜单中，因此在菜单项过多的情况下可能超出菜单栏的显示范围。
- `ifRoom`：在空间足够时，菜单项会显示在菜单栏中，否则收纳入溢出菜单中。
- `withText`：无论菜单项是否定义了icon属性，都只会显示它的标题，而不会显示图标。使用这种方式的菜单项默认会被收纳入溢出菜单中。
- `never`：菜单项永远只会出现在溢出菜单中



要在Activity中使用菜单，[`MenuInflater.inflate()`](https://developer.android.com/reference/android/view/MenuInflater.html?hl=zh-cn#inflate(int,%20android.view.Menu)) 扩充菜单资源（将 XML 资源转换为可编程对象），如有必要，您可以使用 `android:orderInCategory` 属性，对需要移动的每个 `<item>` 中的菜单项重新排序。

为Activity指定选项菜单，[`onCreateOptionsMenu()`](https://developer.android.com/reference/android/app/Activity.html?hl=zh-cn#onCreateOptionsMenu(android.view.Menu)) 。通过此方法，可以将菜单资源（XML中定义）扩充到回调中提供的[`Menu`](https://developer.android.com/reference/android/view/Menu.html?hl=zh-cn)中。

onCreateOptionsMenu()方法。（**菜单初始化**）

```java
//当菜单第一次加载被调用 
@Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main,menu);//填充选项菜单（读取XML文件，解析，加载到Menu组件上）
        return true;
    }
```

还可以使用 `add()` 添加菜单项，并使用 `findItem()` 检索项目，以便使用 `MenuItem` API 修改其属性。

**定义菜单响应事件**（菜单项被选中，完成事件处理）：用户从选项菜单中选择项目（包括应用栏中的操作项目）时，系统将调用 Activity 的 `onOptionsItemSelected()` 方法。 此方法将传递所选的 `MenuItem`。您可以通过调用 `getItemId()` 方法来识别项目，该方法将返回菜单项的唯一 ID（由菜单资源中的 `android:id` 属性定义，或通过提供给 `add()` 方法的整型数定义）。 您可以将此 ID 与已知的菜单项匹配，以执行适当的操作

```java
 @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.add_item:
                Toast.makeText(this,"You clicked Add", Toast.LENGTH_SHORT).show();
                break;
            case R.id.remove_item:
                Toast.makeText(this,"You clikced Remove", Toast.LENGTH_SHORT).show();
                break;
            default:
        }
        return true;
    }
```

- public void **onOptionsMenuClosed**(Menu menu)：菜单关闭会调用该方法
- public boolean **onPrepareOptionsMenu**(Menu menu)：选项菜单显示前会调用该方法， 可在这里进行菜单的调整(动态加载菜单列表)
- public boolean **onMenuOpened**(int featureId, Menu menu)：选项菜单打开以后会调用这个方法



**在Android中菜单有如下几种**：

- **OptionMenu**：选项菜单，android中最常见的菜单，通过Menu键来调用
- **SubMenu**：子菜单，android中点击子菜单将弹出一个显示子菜单项的悬浮框， 子菜单不支持嵌套，即不能包括其他子菜单
- **ContextMenu**：上下文菜单，通过长按某个视图组件后出现的菜单，该组件需注册上下文菜单



## OptionMenu

关于使用**OptionMenu**用法，主要涉及重写以下几种方法：

- public boolean **onCreateOptionsMenu**(Menu menu)：调用OptionMenu，在这里完成**<font color=red>菜单初始化</font>**
- public boolean **onOptionsItemSelected**(MenuItem item)：菜单项被选中时触发，这里**<font color=red>完成事件处理</font>**
- public void **onOptionsMenuClosed**(Menu menu)：**<font color=red>菜单关闭</font>**会调用该方法
- public boolean **onPrepareOptionsMenu**(Menu menu)：选项菜单**<font color=red>显示前会调用</font>**该方法， 可在这里进行菜单的调整(动态加载菜单列表)
- public boolean **onMenuOpened**(int featureId, Menu menu)：选项菜单**<font color=red>打开以后会调用</font>**这个方法



**<font color=red>加载菜单有两种方式</font>>**：

- 直接通过编写菜单XML文件，然后调用： **getMenuInflater().inflate(R.menu.menu_main, menu);**加载菜单 
  - 第一个参数用于指定通过哪一个资源文件创建菜单
  - 第二个参数用于指定菜单项将添加到哪一个Menu对象中。
- 通过Java代码动态加载，**onCreateOptionsMenu**的参数menu，调用`add()`方法添加 菜单，**add(菜单项的组号，ID，排序号，标题)**，另外如果排序号是按添加顺序排序的话都填0即可

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/add_item"
        android:icon="@drawable/banana_pic"
        android:title="Add"
        app:showAsAction="ifRoom"/>
    <item
        android:id="@+id/remove_item"
        android:title="Remove"
        app:showAsAction="ifRoom"/>
</menu>
```

```java
@Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.main, menu);
        menu.add(0, 110, 1, "Start");
        menu.add(0, 111, 2, "Over");
        return true;
    }
```

 重写**OptionsItemSelected(MenuItem item)**来响应菜单项(**MenuItem**)的点击事件（根据id来区分是哪个item）

```java
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.add_item:
            Toast.makeText(this, "you click add", Toast.LENGTH_SHORT ).show();
            break;
        case 110:
            Toast.makeText(this, "you click Start", Toast.LENGTH_SHORT).show();
            break;
        default:
            Toast.makeText(this, "you click other Button", Toast.LENGTH_SHORT).show();
            break;
    }
    return super.onOptionsItemSelected(item);
}
```

Android 3.0 新增了一项功能，支持您在 XML 中使用 `android:onClick` 属性为菜单项定义点击行为。该属性的值必须是 Activity 使用菜单定义的方法的名称。 该方法必须是公用的，且接受单个 `MenuItem`参数；当系统调用此方法时，它会传递所选的菜单项

### 在运行时修改选项菜单

我们**只应该**使用`onCreateOptionsMenu`来创建**初始菜单状态**，而不应使用它在Activity生命周期中对菜单执行任何更改。**如果需要根据在Activity生命周期中发生的某些事件修改选项菜单，则应该通过`onPrepareOptionsMenu`方法实现**。这个方法的参数中有一个Menu对象（即旧的Menu对象），我们可以使用它对菜单执行修改，如添加、移除、启用或禁用菜单项。

```java
private boolean flag_enable = true;
...
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    menu.findItem(R.id.add_item).setEnabled(flag_enable);
    menu.findItem(R.id.remove_item).setEnabled(!flag_enable);
    menu.findItem(110).setEnabled(flag_enable);
    menu.findItem(111).setEnabled(false);
    return true;
}

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
        case R.id.add_item:
            flag_enable = !flag_enable;
            invalidateOptionsMenu();
            Toast.makeText(this, "you click add", Toast.LENGTH_SHORT ).show();
            break;
        case 110:
            flag_enable = !flag_enable;
            invalidateOptionsMenu();
            Toast.makeText(this, "you click Start", Toast.LENGTH_SHORT).show();
            break;
        default:
            flag_enable = !flag_enable;
            invalidateOptionsMenu();
            Toast.makeText(this, "you click other Button", Toast.LENGTH_SHORT).show();
            break;
    }
    return super.onOptionsItemSelected(item);
}
```

上述代码中   `invalidateOptionsMenu();`通知系统刷新menu。

## ContextMenu（上下文菜单）

**ContextMenu**即长按某个View后出现的菜单，需要为这个View注册上下文菜单。

**<font color=red>ContextMenu使用流程</font>**：

- **Step 1**：重写**onCreateContextMenu()**方法
- **Step 2**：为view组件注册上下文菜单，使用**registerForContextMenu()**方法,**参数是View**
- **Step 3**：重写**onContextItemSelected()**方法为菜单项指定事件监听器

### 创建浮动上下文菜单

使用[浮动上下文菜单](https://developer.android.com/guide/topics/ui/menus?hl=zh-cn#FloatingContextMenu)。用户长按（按住）一个声明支持上下文菜单的视图时，菜单显示为菜单项的浮动列表（类似于对话框）。

- 首先编写选项菜单的菜单XML文件：

```xml
<item android:id="@+id/context_option_add"
    android:title="添加"/>
<item android:id="@+id/context_option_delete"
    android:title="删除"/>
<item android:id="@+id/context_option_save"
    android:title="保存"/>
```

- 编写Java代码：(**<font color = red>待研读</font>**)

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_context_menu);

    //初始化ListView
    ListView listView= (ListView) findViewById(R.id.list_context_menu);
    ArrayAdapter<String> adapter=new ArrayAdapter<String>(this,
            android.R.layout.simple_list_item_1,createDataList());
    listView.setAdapter(adapter);

    //为ListView注册上下文浮动菜单
    registerForContextMenu(listView);
}

//生成测试数据List
private List<String> createDataList(){
    List<String> list=new ArrayList<>();
    for(int i=0;i<10;i++){
        list.add("测试条目"+i);
    }
    return list;
}

@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    MenuInflater inflater=getMenuInflater();
    inflater.inflate(R.menu.context_menu,menu);
}

@Override
public boolean onContextItemSelected(MenuItem item) {
    switch (item.getItemId()){
        case R.id.context_option_add:
            Toast.makeText(this,"添加",Toast.LENGTH_SHORT).show();
            return true;
        case R.id.context_option_save:
            Toast.makeText(this,"保存",Toast.LENGTH_SHORT).show();
            return true;
        case R.id.context_option_delete:
            Toast.makeText(this,"删除",Toast.LENGTH_SHORT).show();
            return true;
        default:
            return super.onContextItemSelected(item);
    }
}
```

代码示例：

编写选项菜单的菜单XML文件：

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- 定义一组单选按钮 -->
    <!-- checkableBehavior的可选值由三个：single设置为单选，all为多选，none为普通选项 -->
    <group android:checkableBehavior="none">
        <item android:id="@+id/blue" android:title="@string/font_blue"/>
        <item android:id="@+id/green" android:title="@string/font_green"/>
        <item android:id="@+id/red" android:title="@string/font_red"/>
    </group>
</menu>
```

在布局文件中添加一个TextView，然后：

```java
private TextView tv_context;
//在onCreate中添加
tv_context = (TextView) findViewById(R.id.tv_context);
        registerForContextMenu(tv_context);

    //重写与ContextMenu相关方法
    @Override
    //重写上下文菜单的创建方法
    public void onCreateContextMenu(ContextMenu menu, View v,
                                    ContextMenu.ContextMenuInfo menuInfo) {
        MenuInflater inflator = new MenuInflater(this);
        inflator.inflate(R.menu.menu_context, menu);
        super.onCreateContextMenu(menu, v, menuInfo);
    }

    //上下文菜单被点击是触发该方法
    @Override
    public boolean onContextItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.blue:
                tv_context.setTextColor(Color.BLUE);
                break;
            case R.id.green:
                tv_context.setTextColor(Color.GREEN);
                break;
            case R.id.red:
                tv_context.setTextColor(Color.RED);
                break;
        }
        return true;
    }
```



### 使用上下文操作模式

上下文操作模式是`ActionMode`的系统实现，它将在屏幕顶部（菜单栏区域）显示上下文操作栏，其中包括影响所选项目的多种菜单项（通过加载Menu资源）。当启动这个模式时，用户可以同时对多个项目执行操作（批处理）

当用户取消选择所有项目、按“返回”按钮或选择操作栏左侧的“完成”操作时，该操作模式将会结束，同时上下文操作栏会消失